#!/usr/bin/env node

/**
 * Content Issue Creator
 *
 * Creates GitHub issues for content items that need immediate attention
 * based on freshness analysis results.
 */

import { readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const CONFIG = {
  REPORTS_DIR: '.content-reports',
  FRESHNESS_REPORT: 'freshness-report.json',
  RECOMMENDATIONS_REPORT: 'content-recommendations.json',
};

/**
 * Load content reports
 */
function loadReports() {
  const freshnessPath = join(CONFIG.REPORTS_DIR, CONFIG.FRESHNESS_REPORT);
  const recommendationsPath = join(CONFIG.REPORTS_DIR, CONFIG.RECOMMENDATIONS_REPORT);

  if (!existsSync(freshnessPath)) {
    console.log('No freshness report found, skipping issue creation');
    return null;
  }

  const freshnessReport = JSON.parse(readFileSync(freshnessPath, 'utf8'));
  const recommendationsReport = existsSync(recommendationsPath)
    ? JSON.parse(readFileSync(recommendationsPath, 'utf8'))
    : null;

  return { freshnessReport, recommendationsReport };
}

/**
 * Generate issue content for critical content items
 */
function generateIssueContent(reports) {
  const { freshnessReport, recommendationsReport } = reports;

  // Find critical content items
  const criticalItems = freshnessReport.content.filter(
    item => !item.error && (item.status === 'EXPIRED' || item.status === 'STALE')
  );

  if (criticalItems.length === 0) {
    return null;
  }

  // Group items by urgency
  const expiredItems = criticalItems.filter(item => item.status === 'EXPIRED');
  const staleItems = criticalItems.filter(item => item.status === 'STALE');

  let issueBody = `# üö® Critical Content Updates Required

**Generated:** ${new Date().toLocaleDateString()}

## Summary

- **Expired Content:** ${expiredItems.length} items (immediate action required)
- **Stale Content:** ${staleItems.length} items (update this month)
- **Total Items Needing Attention:** ${criticalItems.length}

## Immediate Action Required

### Expired Content (${expiredItems.length} items)

The following content is expired and needs immediate attention:

${expiredItems
  .map(item => {
    const recommendations =
      recommendationsReport?.contentUpdates?.find(update => update.filePath === item.filePath)
        ?.recommendations || [];

    return `### ${item.title}
**File:** \`${item.filePath}\`
**Age:** ${item.daysOld} days old
**Content Type:** ${item.contentType}

**Issues:**
${item.recommendations.map(rec => `- ${rec.message}`).join('\n')}

**Recommended Actions:**
${recommendations
  .slice(0, 3)
  .map(rec => `- ${rec.title}`)
  .join('\n')}

**Priority:** üö® CRITICAL - Update within 48 hours
`;
  })
  .join('\n---\n')}

### Stale Content (${staleItems.length} items)

The following content is stale and should be updated this month:

${staleItems
  .map(item => {
    const recommendations =
      recommendationsReport?.contentUpdates?.find(update => update.filePath === item.filePath)
        ?.recommendations || [];

    return `#### ${item.title}
- **File:** \`${item.filePath}\`
- **Age:** ${item.daysOld} days old
- **Top Action:** ${recommendations[0]?.title || 'Comprehensive refresh needed'}
`;
  })
  .join('\n')}

## Next Steps

1. **Immediate (This Week):** Update all expired content items
2. **This Month:** Address all stale content items
3. **Ongoing:** Implement regular content review schedule

## Bulk Updates Available

The following bulk operations could address multiple items efficiently:

${
  recommendationsReport?.bulkOperations
    ?.map(op => `- **${op.title}:** ${op.affectedItems} items affected`)
    .join('\n') || 'No bulk operations identified'
}

---

*This issue was automatically generated by the content freshness monitoring system. Issues will be resolved when content is updated and the next monitoring cycle runs successfully.*`;

  return {
    title: `üö® Critical Content Updates Required (${expiredItems.length} expired, ${staleItems.length} stale)`,
    body: issueBody,
    labels: ['content-maintenance', 'urgent', 'automated'],
    priority: 'high',
  };
}

/**
 * Create GitHub issue using GitHub CLI
 */
function createGitHubIssue(issueContent) {
  try {
    // Create issue with GitHub CLI
    const command = `gh issue create \
      --title "${issueContent.title.replace(/"/g, '\\"')}" \
      --body "${issueContent.body.replace(/"/g, '\\"')}" \
      --label ${issueContent.labels.join(',')} \
      --assignee @me`;

    console.log('Creating GitHub issue...');
    const result = execSync(command, { encoding: 'utf8', stdio: 'pipe' });

    // Extract issue URL from result
    const issueUrl = result.trim().match(/https:\/\/github\.com\/[^\\s]+/)?.[0];

    console.log(`‚úÖ Issue created: ${issueUrl}`);
    return issueUrl;
  } catch (error) {
    console.error('Failed to create GitHub issue:', error.message);
    return null;
  }
}

/**
 * Check if similar issue already exists
 */
function checkExistingIssue(title) {
  try {
    const searchCommand = `gh issue list --search "${title}" --state open --limit 1 --json url,title`;
    const result = execSync(searchCommand, { encoding: 'utf8', stdio: 'pipe' });
    const issues = JSON.parse(result);

    return issues.length > 0 ? issues[0].url : null;
  } catch (error) {
    console.warn('Could not check for existing issues:', error.message);
    return null;
  }
}

/**
 * Main execution function
 */
function main() {
  console.log('üìù Creating content update issues...\n');

  try {
    const reports = loadReports();

    if (!reports) {
      console.log('No reports available, skipping issue creation');
      return;
    }

    const issueContent = generateIssueContent(reports);

    if (!issueContent) {
      console.log('‚úÖ No critical content updates required');
      return;
    }

    // Check if similar issue already exists
    const existingIssue = checkExistingIssue(issueContent.title);
    if (existingIssue) {
      console.log(`‚ÑπÔ∏è Similar issue already exists: ${existingIssue}`);
      return;
    }

    // Create new issue
    const issueUrl = createGitHubIssue(issueContent);

    if (issueUrl) {
      console.log('\n‚úÖ Content update issue created successfully');
      console.log(`üîó Issue: ${issueUrl}`);
    } else {
      console.error('\n‚ùå Failed to create content update issue');
      process.exit(1);
    }
  } catch (error) {
    console.error('\n‚ùå Error creating content issues:', error.message);
    process.exit(1);
  }
}

// Import execSync for GitHub CLI commands
import { execSync } from 'node:child_process';

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { generateIssueContent, createGitHubIssue };
